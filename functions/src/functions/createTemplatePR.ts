import { app, HttpRequest, HttpResponseInit, InvocationContext } from '@azure/functions';
import { validateToken } from '../shared/auth.js';

interface IDiffSummary {
  added: string[];
  modified: string[];
  removed: string[];
}

interface ICreatePRRequest {
  updatedRegistry: unknown;
  updatedPnpTemplates: Record<string, string>;
  diffSummary: IDiffSummary;
  triggeredBy?: string;
}

async function githubGet(path: string, token: string): Promise<unknown> {
  const resp = await fetch(`https://api.github.com${path}`, {
    headers: {
      Authorization: `token ${token}`,
      Accept: 'application/vnd.github.v3+json',
      'User-Agent': 'HBC-GitOps-Function/1.0',
    },
  });
  if (!resp.ok) throw new Error(`GitHub GET ${path} → ${resp.status}: ${await resp.text()}`);
  return resp.json();
}

async function githubPost(path: string, body: unknown, token: string): Promise<unknown> {
  const resp = await fetch(`https://api.github.com${path}`, {
    method: 'POST',
    headers: {
      Authorization: `token ${token}`,
      Accept: 'application/vnd.github.v3+json',
      'Content-Type': 'application/json',
      'User-Agent': 'HBC-GitOps-Function/1.0',
    },
    body: JSON.stringify(body),
  });
  if (!resp.ok) throw new Error(`GitHub POST ${path} → ${resp.status}: ${await resp.text()}`);
  return resp.json();
}

async function upsertFile(
  owner: string,
  repo: string,
  branch: string,
  filePath: string,
  content: string,
  message: string,
  token: string
): Promise<void> {
  // Try to get existing file SHA so we can update rather than create
  let sha: string | undefined;
  try {
    const existing = (await githubGet(
      `/repos/${owner}/${repo}/contents/${filePath}?ref=${branch}`,
      token
    )) as { sha?: string };
    sha = existing.sha;
  } catch {
    // File does not exist yet — that is fine, we will create it
  }

  await githubPost(
    `/repos/${owner}/${repo}/contents/${filePath}`,
    {
      message,
      content: Buffer.from(content).toString('base64'),
      branch,
      ...(sha ? { sha } : {}),
    },
    token
  );
}

function buildPRBody(diffSummary: IDiffSummary, triggeredBy: string): string {
  const dateStr = new Date().toISOString().slice(0, 10);
  return [
    `## Template Site Sync — ${dateStr}`,
    ``,
    `**Triggered by:** ${triggeredBy}`,
    ``,
    `### Changes`,
    `- **Added (${diffSummary.added.length}):** ${diffSummary.added.join(', ') || 'none'}`,
    `- **Modified (${diffSummary.modified.length}):** ${diffSummary.modified.join(', ') || 'none'}`,
    `- **Removed (${diffSummary.removed.length}):** ${diffSummary.removed.join(', ') || 'none'}`,
    ``,
    `---`,
    `*Auto-generated by HBC GitOps Template Sync*`,
  ].join('\n');
}

async function createTemplatePR(
  request: HttpRequest,
  context: InvocationContext
): Promise<HttpResponseInit> {
  try {
    const user = await validateToken(request.headers.get('authorization') || undefined);
    const body = (await request.json()) as ICreatePRRequest;

    if (!body?.updatedRegistry || !body?.diffSummary) {
      return {
        status: 400,
        jsonBody: { error: 'Missing required fields: updatedRegistry, diffSummary' },
      };
    }

    const githubToken = process.env.GITHUB_APP_TOKEN;
    const owner = process.env.GITHUB_REPO_OWNER;
    const repo = process.env.GITHUB_REPO_NAME;
    const base = process.env.GITHUB_BASE_BRANCH ?? 'main';

    if (!githubToken || !owner || !repo) {
      return {
        status: 500,
        jsonBody: { error: 'Missing required environment configuration' },
      };
    }

    const dateStr = new Date().toISOString().slice(0, 10);
    const hashStr = Math.random().toString(36).slice(2, 6);
    const branchName = `templates/sync-${dateStr}-${hashStr}`;

    // 1. Get base branch SHA
    const baseRef = (await githubGet(
      `/repos/${owner}/${repo}/git/ref/heads/${base}`,
      githubToken
    )) as { object: { sha: string } };

    // 2. Create the sync branch from base
    await githubPost(
      `/repos/${owner}/${repo}/git/refs`,
      {
        ref: `refs/heads/${branchName}`,
        sha: baseRef.object.sha,
      },
      githubToken
    );

    // 3. Commit updated template-registry.json
    const addedCount = body.diffSummary.added?.length ?? 0;
    await upsertFile(
      owner,
      repo,
      branchName,
      'templates/template-registry.json',
      JSON.stringify(body.updatedRegistry, null, 2),
      `chore(templates): sync template-registry — ${addedCount} added`,
      githubToken
    );

    // 4. Commit per-division pnp-template.json files
    for (const [division, content] of Object.entries(body.updatedPnpTemplates ?? {})) {
      await upsertFile(
        owner,
        repo,
        branchName,
        `templates/${division}/pnp-template.json`,
        content,
        `chore(templates): update ${division} PnP template`,
        githubToken
      );
    }

    // 5. Open the pull request
    const triggeredBy = body.triggeredBy ?? user.email;
    const pr = (await githubPost(
      `/repos/${owner}/${repo}/pulls`,
      {
        title: `chore(templates): sync from Template Site — ${dateStr}`,
        body: buildPRBody(body.diffSummary, triggeredBy),
        head: branchName,
        base,
      },
      githubToken
    )) as { number: number; html_url: string };

    context.log(`[createTemplatePR] PR #${pr.number} created by ${user.email}`);

    return {
      status: 201,
      jsonBody: { prNumber: pr.number, prUrl: pr.html_url, branchName },
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    // Log full detail server-side only — GitHub error bodies may contain API internals
    context.error('[createTemplatePR] Operation failed:', message);
    // Return sanitized message to client — GitHub errors can include verbose API response bodies
    const clientMessage = message.startsWith('GitHub ')
      ? 'GitHub API error — check function logs for details'
      : 'Internal server error — check function logs for details';
    return { status: 500, jsonBody: { error: clientMessage } };
  }
}

app.http('createTemplatePR', {
  methods: ['POST'],
  authLevel: 'anonymous',
  route: 'create-template-pr',
  handler: createTemplatePR,
});
