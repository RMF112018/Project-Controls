"use strict";(self.webpackChunkhbc_project_controls=self.webpackChunkhbc_project_controls||[]).push([[11],{"./node_modules/@microsoft/signalr/dist/esm/index.js"(__unused_webpack_module,__webpack_exports__,__webpack_require__){__webpack_require__.d(__webpack_exports__,{HubConnectionBuilder:()=>HubConnectionBuilder,LogLevel:()=>LogLevel});const DEFAULT_RETRY_DELAYS_IN_MILLISECONDS=[0,2e3,1e4,3e4,null];class DefaultReconnectPolicy{constructor(retryDelays){this._retryDelays=void 0!==retryDelays?[...retryDelays,null]:DEFAULT_RETRY_DELAYS_IN_MILLISECONDS}nextRetryDelayInMilliseconds(retryContext){return this._retryDelays[retryContext.previousRetryCount]}}class HeaderNames{}HeaderNames.Authorization="Authorization",HeaderNames.Cookie="Cookie";class HttpResponse{constructor(statusCode,statusText,content){this.statusCode=statusCode,this.statusText=statusText,this.content=content}}class HttpClient{get(url,options){return this.send({...options,method:"GET",url})}post(url,options){return this.send({...options,method:"POST",url})}delete(url,options){return this.send({...options,method:"DELETE",url})}getCookieString(url){return""}}class AccessTokenHttpClient extends HttpClient{constructor(innerClient,accessTokenFactory){super(),this._innerClient=innerClient,this._accessTokenFactory=accessTokenFactory}async send(request){let allowRetry=!0;this._accessTokenFactory&&(!this._accessToken||request.url&&request.url.indexOf("/negotiate?")>0)&&(allowRetry=!1,this._accessToken=await this._accessTokenFactory()),this._setAuthorizationHeader(request);const response=await this._innerClient.send(request);return allowRetry&&401===response.statusCode&&this._accessTokenFactory?(this._accessToken=await this._accessTokenFactory(),this._setAuthorizationHeader(request),await this._innerClient.send(request)):response}_setAuthorizationHeader(request){request.headers||(request.headers={}),this._accessToken?request.headers[HeaderNames.Authorization]=`Bearer ${this._accessToken}`:this._accessTokenFactory&&request.headers[HeaderNames.Authorization]&&delete request.headers[HeaderNames.Authorization]}getCookieString(url){return this._innerClient.getCookieString(url)}}class HttpError extends Error{constructor(errorMessage,statusCode){const trueProto=new.target.prototype;super(`${errorMessage}: Status code '${statusCode}'`),this.statusCode=statusCode,this.__proto__=trueProto}}class TimeoutError extends Error{constructor(errorMessage="A timeout occurred."){const trueProto=new.target.prototype;super(errorMessage),this.__proto__=trueProto}}class AbortError extends Error{constructor(errorMessage="An abort occurred."){const trueProto=new.target.prototype;super(errorMessage),this.__proto__=trueProto}}class UnsupportedTransportError extends Error{constructor(message,transport){const trueProto=new.target.prototype;super(message),this.transport=transport,this.errorType="UnsupportedTransportError",this.__proto__=trueProto}}class DisabledTransportError extends Error{constructor(message,transport){const trueProto=new.target.prototype;super(message),this.transport=transport,this.errorType="DisabledTransportError",this.__proto__=trueProto}}class FailedToStartTransportError extends Error{constructor(message,transport){const trueProto=new.target.prototype;super(message),this.transport=transport,this.errorType="FailedToStartTransportError",this.__proto__=trueProto}}class FailedToNegotiateWithServerError extends Error{constructor(message){const trueProto=new.target.prototype;super(message),this.errorType="FailedToNegotiateWithServerError",this.__proto__=trueProto}}class AggregateErrors extends Error{constructor(message,innerErrors){const trueProto=new.target.prototype;super(message),this.innerErrors=innerErrors,this.__proto__=trueProto}}var LogLevel;!function(LogLevel){LogLevel[LogLevel.Trace=0]="Trace",LogLevel[LogLevel.Debug=1]="Debug",LogLevel[LogLevel.Information=2]="Information",LogLevel[LogLevel.Warning=3]="Warning",LogLevel[LogLevel.Error=4]="Error",LogLevel[LogLevel.Critical=5]="Critical",LogLevel[LogLevel.None=6]="None"}(LogLevel||(LogLevel={}));class NullLogger{constructor(){}log(_logLevel,_message){}}NullLogger.instance=new NullLogger;var HttpTransportType,TransferFormat,process=__webpack_require__("./node_modules/process/browser.js");class Arg{static isRequired(val,name){if(null==val)throw new Error(`The '${name}' argument is required.`)}static isNotEmpty(val,name){if(!val||val.match(/^\s*$/))throw new Error(`The '${name}' argument should not be empty.`)}static isIn(val,values,name){if(!(val in values))throw new Error(`Unknown ${name} value: ${val}.`)}}class Platform{static get isBrowser(){return!Platform.isNode&&"object"==typeof window&&"object"==typeof window.document}static get isWebWorker(){return!Platform.isNode&&"object"==typeof self&&"importScripts"in self}static get isReactNative(){return!Platform.isNode&&"object"==typeof window&&void 0===window.document}static get isNode(){return void 0!==process&&process.release&&"node"===process.release.name}}function getDataDetail(data,includeContent){let detail="";return isArrayBuffer(data)?(detail=`Binary data of length ${data.byteLength}`,includeContent&&(detail+=`. Content: '${function formatArrayBuffer(data){const view=new Uint8Array(data);let str="";return view.forEach(num=>{str+=`0x${num<16?"0":""}${num.toString(16)} `}),str.substring(0,str.length-1)}(data)}'`)):"string"==typeof data&&(detail=`String data of length ${data.length}`,includeContent&&(detail+=`. Content: '${data}'`)),detail}function isArrayBuffer(val){return val&&"undefined"!=typeof ArrayBuffer&&(val instanceof ArrayBuffer||val.constructor&&"ArrayBuffer"===val.constructor.name)}async function sendMessage(logger,transportName,httpClient,url,content,options){const headers={},[name,value]=getUserAgentHeader();headers[name]=value,logger.log(LogLevel.Trace,`(${transportName} transport) sending data. ${getDataDetail(content,options.logMessageContent)}.`);const responseType=isArrayBuffer(content)?"arraybuffer":"text",response=await httpClient.post(url,{content,headers:{...headers,...options.headers},responseType,timeout:options.timeout,withCredentials:options.withCredentials});logger.log(LogLevel.Trace,`(${transportName} transport) request complete. Response status: ${response.statusCode}.`)}class SubjectSubscription{constructor(subject,observer){this._subject=subject,this._observer=observer}dispose(){const index=this._subject.observers.indexOf(this._observer);index>-1&&this._subject.observers.splice(index,1),0===this._subject.observers.length&&this._subject.cancelCallback&&this._subject.cancelCallback().catch(_=>{})}}class ConsoleLogger{constructor(minimumLogLevel){this._minLevel=minimumLogLevel,this.out=console}log(logLevel,message){if(logLevel>=this._minLevel){const msg=`[${(new Date).toISOString()}] ${LogLevel[logLevel]}: ${message}`;switch(logLevel){case LogLevel.Critical:case LogLevel.Error:this.out.error(msg);break;case LogLevel.Warning:this.out.warn(msg);break;case LogLevel.Information:this.out.info(msg);break;default:this.out.log(msg)}}}}function getUserAgentHeader(){let userAgentHeaderName="X-SignalR-User-Agent";return Platform.isNode&&(userAgentHeaderName="User-Agent"),[userAgentHeaderName,constructUserAgent("10.0.0",getOsName(),getRuntime(),getRuntimeVersion())]}function constructUserAgent(version,os,runtime,runtimeVersion){let userAgent="Microsoft SignalR/";const majorAndMinor=version.split(".");return userAgent+=`${majorAndMinor[0]}.${majorAndMinor[1]}`,userAgent+=` (${version}; `,userAgent+=os&&""!==os?`${os}; `:"Unknown OS; ",userAgent+=`${runtime}`,userAgent+=runtimeVersion?`; ${runtimeVersion}`:"; Unknown Runtime Version",userAgent+=")",userAgent}function getOsName(){if(!Platform.isNode)return"";switch(process.platform){case"win32":return"Windows NT";case"darwin":return"macOS";case"linux":return"Linux";default:return process.platform}}function getRuntimeVersion(){if(Platform.isNode)return process.versions.node}function getRuntime(){return Platform.isNode?"NodeJS":"Browser"}function getErrorString(e){return e.stack?e.stack:e.message?e.message:`${e}`}class FetchHttpClient extends HttpClient{constructor(logger){if(super(),this._logger=logger,"undefined"==typeof fetch||Platform.isNode){const requireFunc=require;this._jar=new(requireFunc("tough-cookie").CookieJar),"undefined"==typeof fetch?this._fetchType=requireFunc("node-fetch"):this._fetchType=fetch,this._fetchType=requireFunc("fetch-cookie")(this._fetchType,this._jar)}else this._fetchType=fetch.bind(function getGlobalThis(){if("undefined"!=typeof globalThis)return globalThis;if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if(void 0!==__webpack_require__.g)return __webpack_require__.g;throw new Error("could not find global")}());if("undefined"==typeof AbortController){const requireFunc=require;this._abortControllerType=requireFunc("abort-controller")}else this._abortControllerType=AbortController}async send(request){if(request.abortSignal&&request.abortSignal.aborted)throw new AbortError;if(!request.method)throw new Error("No method defined.");if(!request.url)throw new Error("No url defined.");const abortController=new this._abortControllerType;let error;request.abortSignal&&(request.abortSignal.onabort=()=>{abortController.abort(),error=new AbortError});let response,timeoutId=null;if(request.timeout){const msTimeout=request.timeout;timeoutId=setTimeout(()=>{abortController.abort(),this._logger.log(LogLevel.Warning,"Timeout from HTTP request."),error=new TimeoutError},msTimeout)}""===request.content&&(request.content=void 0),request.content&&(request.headers=request.headers||{},isArrayBuffer(request.content)?request.headers["Content-Type"]="application/octet-stream":request.headers["Content-Type"]="text/plain;charset=UTF-8");try{response=await this._fetchType(request.url,{body:request.content,cache:"no-cache",credentials:!0===request.withCredentials?"include":"same-origin",headers:{"X-Requested-With":"XMLHttpRequest",...request.headers},method:request.method,mode:"cors",redirect:"follow",signal:abortController.signal})}catch(e){if(error)throw error;throw this._logger.log(LogLevel.Warning,`Error from HTTP request. ${e}.`),e}finally{timeoutId&&clearTimeout(timeoutId),request.abortSignal&&(request.abortSignal.onabort=null)}if(!response.ok){const errorMessage=await deserializeContent(response,"text");throw new HttpError(errorMessage||response.statusText,response.status)}const content=deserializeContent(response,request.responseType),payload=await content;return new HttpResponse(response.status,response.statusText,payload)}getCookieString(url){let cookies="";return Platform.isNode&&this._jar&&this._jar.getCookies(url,(e,c)=>cookies=c.join("; ")),cookies}}function deserializeContent(response,responseType){let content;switch(responseType){case"arraybuffer":content=response.arrayBuffer();break;case"text":default:content=response.text();break;case"blob":case"document":case"json":throw new Error(`${responseType} is not supported.`)}return content}class XhrHttpClient extends HttpClient{constructor(logger){super(),this._logger=logger}send(request){return request.abortSignal&&request.abortSignal.aborted?Promise.reject(new AbortError):request.method?request.url?new Promise((resolve,reject)=>{const xhr=new XMLHttpRequest;xhr.open(request.method,request.url,!0),xhr.withCredentials=void 0===request.withCredentials||request.withCredentials,xhr.setRequestHeader("X-Requested-With","XMLHttpRequest"),""===request.content&&(request.content=void 0),request.content&&(isArrayBuffer(request.content)?xhr.setRequestHeader("Content-Type","application/octet-stream"):xhr.setRequestHeader("Content-Type","text/plain;charset=UTF-8"));const headers=request.headers;headers&&Object.keys(headers).forEach(header=>{xhr.setRequestHeader(header,headers[header])}),request.responseType&&(xhr.responseType=request.responseType),request.abortSignal&&(request.abortSignal.onabort=()=>{xhr.abort(),reject(new AbortError)}),request.timeout&&(xhr.timeout=request.timeout),xhr.onload=()=>{request.abortSignal&&(request.abortSignal.onabort=null),xhr.status>=200&&xhr.status<300?resolve(new HttpResponse(xhr.status,xhr.statusText,xhr.response||xhr.responseText)):reject(new HttpError(xhr.response||xhr.responseText||xhr.statusText,xhr.status))},xhr.onerror=()=>{this._logger.log(LogLevel.Warning,`Error from HTTP request. ${xhr.status}: ${xhr.statusText}.`),reject(new HttpError(xhr.statusText,xhr.status))},xhr.ontimeout=()=>{this._logger.log(LogLevel.Warning,"Timeout from HTTP request."),reject(new TimeoutError)},xhr.send(request.content)}):Promise.reject(new Error("No url defined.")):Promise.reject(new Error("No method defined."))}}class DefaultHttpClient extends HttpClient{constructor(logger){if(super(),"undefined"!=typeof fetch||Platform.isNode)this._httpClient=new FetchHttpClient(logger);else{if("undefined"==typeof XMLHttpRequest)throw new Error("No usable HttpClient found.");this._httpClient=new XhrHttpClient(logger)}}send(request){return request.abortSignal&&request.abortSignal.aborted?Promise.reject(new AbortError):request.method?request.url?this._httpClient.send(request):Promise.reject(new Error("No url defined.")):Promise.reject(new Error("No method defined."))}getCookieString(url){return this._httpClient.getCookieString(url)}}!function(HttpTransportType){HttpTransportType[HttpTransportType.None=0]="None",HttpTransportType[HttpTransportType.WebSockets=1]="WebSockets",HttpTransportType[HttpTransportType.ServerSentEvents=2]="ServerSentEvents",HttpTransportType[HttpTransportType.LongPolling=4]="LongPolling"}(HttpTransportType||(HttpTransportType={})),function(TransferFormat){TransferFormat[TransferFormat.Text=1]="Text",TransferFormat[TransferFormat.Binary=2]="Binary"}(TransferFormat||(TransferFormat={}));class AbortController_AbortController{constructor(){this._isAborted=!1,this.onabort=null}abort(){this._isAborted||(this._isAborted=!0,this.onabort&&this.onabort())}get signal(){return this}get aborted(){return this._isAborted}}class LongPollingTransport{get pollAborted(){return this._pollAbort.aborted}constructor(httpClient,logger,options){this._httpClient=httpClient,this._logger=logger,this._pollAbort=new AbortController_AbortController,this._options=options,this._running=!1,this.onreceive=null,this.onclose=null}async connect(url,transferFormat){if(Arg.isRequired(url,"url"),Arg.isRequired(transferFormat,"transferFormat"),Arg.isIn(transferFormat,TransferFormat,"transferFormat"),this._url=url,this._logger.log(LogLevel.Trace,"(LongPolling transport) Connecting."),transferFormat===TransferFormat.Binary&&"undefined"!=typeof XMLHttpRequest&&"string"!=typeof(new XMLHttpRequest).responseType)throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");const[name,value]=getUserAgentHeader(),headers={[name]:value,...this._options.headers},pollOptions={abortSignal:this._pollAbort.signal,headers,timeout:1e5,withCredentials:this._options.withCredentials};transferFormat===TransferFormat.Binary&&(pollOptions.responseType="arraybuffer");const pollUrl=`${url}&_=${Date.now()}`;this._logger.log(LogLevel.Trace,`(LongPolling transport) polling: ${pollUrl}.`);const response=await this._httpClient.get(pollUrl,pollOptions);200!==response.statusCode?(this._logger.log(LogLevel.Error,`(LongPolling transport) Unexpected response code: ${response.statusCode}.`),this._closeError=new HttpError(response.statusText||"",response.statusCode),this._running=!1):this._running=!0,this._receiving=this._poll(this._url,pollOptions)}async _poll(url,pollOptions){try{for(;this._running;)try{const pollUrl=`${url}&_=${Date.now()}`;this._logger.log(LogLevel.Trace,`(LongPolling transport) polling: ${pollUrl}.`);const response=await this._httpClient.get(pollUrl,pollOptions);204===response.statusCode?(this._logger.log(LogLevel.Information,"(LongPolling transport) Poll terminated by server."),this._running=!1):200!==response.statusCode?(this._logger.log(LogLevel.Error,`(LongPolling transport) Unexpected response code: ${response.statusCode}.`),this._closeError=new HttpError(response.statusText||"",response.statusCode),this._running=!1):response.content?(this._logger.log(LogLevel.Trace,`(LongPolling transport) data received. ${getDataDetail(response.content,this._options.logMessageContent)}.`),this.onreceive&&this.onreceive(response.content)):this._logger.log(LogLevel.Trace,"(LongPolling transport) Poll timed out, reissuing.")}catch(e){this._running?e instanceof TimeoutError?this._logger.log(LogLevel.Trace,"(LongPolling transport) Poll timed out, reissuing."):(this._closeError=e,this._running=!1):this._logger.log(LogLevel.Trace,`(LongPolling transport) Poll errored after shutdown: ${e.message}`)}}finally{this._logger.log(LogLevel.Trace,"(LongPolling transport) Polling complete."),this.pollAborted||this._raiseOnClose()}}async send(data){return this._running?sendMessage(this._logger,"LongPolling",this._httpClient,this._url,data,this._options):Promise.reject(new Error("Cannot send until the transport is connected"))}async stop(){this._logger.log(LogLevel.Trace,"(LongPolling transport) Stopping polling."),this._running=!1,this._pollAbort.abort();try{await this._receiving,this._logger.log(LogLevel.Trace,`(LongPolling transport) sending DELETE request to ${this._url}.`);const headers={},[name,value]=getUserAgentHeader();headers[name]=value;const deleteOptions={headers:{...headers,...this._options.headers},timeout:this._options.timeout,withCredentials:this._options.withCredentials};let error;try{await this._httpClient.delete(this._url,deleteOptions)}catch(err){error=err}error?error instanceof HttpError&&(404===error.statusCode?this._logger.log(LogLevel.Trace,"(LongPolling transport) A 404 response was returned from sending a DELETE request."):this._logger.log(LogLevel.Trace,`(LongPolling transport) Error sending a DELETE request: ${error}`)):this._logger.log(LogLevel.Trace,"(LongPolling transport) DELETE request accepted.")}finally{this._logger.log(LogLevel.Trace,"(LongPolling transport) Stop finished."),this._raiseOnClose()}}_raiseOnClose(){if(this.onclose){let logMessage="(LongPolling transport) Firing onclose event.";this._closeError&&(logMessage+=" Error: "+this._closeError),this._logger.log(LogLevel.Trace,logMessage),this.onclose(this._closeError)}}}class ServerSentEventsTransport{constructor(httpClient,accessToken,logger,options){this._httpClient=httpClient,this._accessToken=accessToken,this._logger=logger,this._options=options,this.onreceive=null,this.onclose=null}async connect(url,transferFormat){return Arg.isRequired(url,"url"),Arg.isRequired(transferFormat,"transferFormat"),Arg.isIn(transferFormat,TransferFormat,"transferFormat"),this._logger.log(LogLevel.Trace,"(SSE transport) Connecting."),this._url=url,this._accessToken&&(url+=(url.indexOf("?")<0?"?":"&")+`access_token=${encodeURIComponent(this._accessToken)}`),new Promise((resolve,reject)=>{let eventSource,opened=!1;if(transferFormat===TransferFormat.Text){if(Platform.isBrowser||Platform.isWebWorker)eventSource=new this._options.EventSource(url,{withCredentials:this._options.withCredentials});else{const cookies=this._httpClient.getCookieString(url),headers={};headers.Cookie=cookies;const[name,value]=getUserAgentHeader();headers[name]=value,eventSource=new this._options.EventSource(url,{withCredentials:this._options.withCredentials,headers:{...headers,...this._options.headers}})}try{eventSource.onmessage=e=>{if(this.onreceive)try{this._logger.log(LogLevel.Trace,`(SSE transport) data received. ${getDataDetail(e.data,this._options.logMessageContent)}.`),this.onreceive(e.data)}catch(error){return void this._close(error)}},eventSource.onerror=e=>{opened?this._close():reject(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled."))},eventSource.onopen=()=>{this._logger.log(LogLevel.Information,`SSE connected to ${this._url}`),this._eventSource=eventSource,opened=!0,resolve()}}catch(e){return void reject(e)}}else reject(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"))})}async send(data){return this._eventSource?sendMessage(this._logger,"SSE",this._httpClient,this._url,data,this._options):Promise.reject(new Error("Cannot send until the transport is connected"))}stop(){return this._close(),Promise.resolve()}_close(e){this._eventSource&&(this._eventSource.close(),this._eventSource=void 0,this.onclose&&this.onclose(e))}}class WebSocketTransport{constructor(httpClient,accessTokenFactory,logger,logMessageContent,webSocketConstructor,headers){this._logger=logger,this._accessTokenFactory=accessTokenFactory,this._logMessageContent=logMessageContent,this._webSocketConstructor=webSocketConstructor,this._httpClient=httpClient,this.onreceive=null,this.onclose=null,this._headers=headers}async connect(url,transferFormat){let token;return Arg.isRequired(url,"url"),Arg.isRequired(transferFormat,"transferFormat"),Arg.isIn(transferFormat,TransferFormat,"transferFormat"),this._logger.log(LogLevel.Trace,"(WebSockets transport) Connecting."),this._accessTokenFactory&&(token=await this._accessTokenFactory()),new Promise((resolve,reject)=>{let webSocket;url=url.replace(/^http/,"ws");const cookies=this._httpClient.getCookieString(url);let opened=!1;if(Platform.isNode||Platform.isReactNative){const headers={},[name,value]=getUserAgentHeader();headers[name]=value,token&&(headers[HeaderNames.Authorization]=`Bearer ${token}`),cookies&&(headers[HeaderNames.Cookie]=cookies),webSocket=new this._webSocketConstructor(url,void 0,{headers:{...headers,...this._headers}})}else token&&(url+=(url.indexOf("?")<0?"?":"&")+`access_token=${encodeURIComponent(token)}`);webSocket||(webSocket=new this._webSocketConstructor(url)),transferFormat===TransferFormat.Binary&&(webSocket.binaryType="arraybuffer"),webSocket.onopen=_event=>{this._logger.log(LogLevel.Information,`WebSocket connected to ${url}.`),this._webSocket=webSocket,opened=!0,resolve()},webSocket.onerror=event=>{let error=null;error="undefined"!=typeof ErrorEvent&&event instanceof ErrorEvent?event.error:"There was an error with the transport",this._logger.log(LogLevel.Information,`(WebSockets transport) ${error}.`)},webSocket.onmessage=message=>{if(this._logger.log(LogLevel.Trace,`(WebSockets transport) data received. ${getDataDetail(message.data,this._logMessageContent)}.`),this.onreceive)try{this.onreceive(message.data)}catch(error){return void this._close(error)}},webSocket.onclose=event=>{if(opened)this._close(event);else{let error=null;error="undefined"!=typeof ErrorEvent&&event instanceof ErrorEvent?event.error:"WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.",reject(new Error(error))}}})}send(data){return this._webSocket&&this._webSocket.readyState===this._webSocketConstructor.OPEN?(this._logger.log(LogLevel.Trace,`(WebSockets transport) sending data. ${getDataDetail(data,this._logMessageContent)}.`),this._webSocket.send(data),Promise.resolve()):Promise.reject("WebSocket is not in the OPEN state")}stop(){return this._webSocket&&this._close(void 0),Promise.resolve()}_close(event){this._webSocket&&(this._webSocket.onclose=()=>{},this._webSocket.onmessage=()=>{},this._webSocket.onerror=()=>{},this._webSocket.close(),this._webSocket=void 0),this._logger.log(LogLevel.Trace,"(WebSockets transport) socket closed."),this.onclose&&(!this._isCloseEvent(event)||!1!==event.wasClean&&1e3===event.code?event instanceof Error?this.onclose(event):this.onclose():this.onclose(new Error(`WebSocket closed with status code: ${event.code} (${event.reason||"no reason given"}).`)))}_isCloseEvent(event){return event&&"boolean"==typeof event.wasClean&&"number"==typeof event.code}}class HttpConnection{constructor(url,options={}){if(this._stopPromiseResolver=()=>{},this.features={},this._negotiateVersion=1,Arg.isRequired(url,"url"),this._logger=function createLogger(logger){return void 0===logger?new ConsoleLogger(LogLevel.Information):null===logger?NullLogger.instance:void 0!==logger.log?logger:new ConsoleLogger(logger)}(options.logger),this.baseUrl=this._resolveUrl(url),(options=options||{}).logMessageContent=void 0!==options.logMessageContent&&options.logMessageContent,"boolean"!=typeof options.withCredentials&&void 0!==options.withCredentials)throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");options.withCredentials=void 0===options.withCredentials||options.withCredentials,options.timeout=void 0===options.timeout?1e5:options.timeout;let webSocketModule=null,eventSourceModule=null;if(Platform.isNode){const requireFunc=require;webSocketModule=requireFunc("ws"),eventSourceModule=requireFunc("eventsource")}Platform.isNode||"undefined"==typeof WebSocket||options.WebSocket?Platform.isNode&&!options.WebSocket&&webSocketModule&&(options.WebSocket=webSocketModule):options.WebSocket=WebSocket,Platform.isNode||"undefined"==typeof EventSource||options.EventSource?Platform.isNode&&!options.EventSource&&void 0!==eventSourceModule&&(options.EventSource=eventSourceModule):options.EventSource=EventSource,this._httpClient=new AccessTokenHttpClient(options.httpClient||new DefaultHttpClient(this._logger),options.accessTokenFactory),this._connectionState="Disconnected",this._connectionStarted=!1,this._options=options,this.onreceive=null,this.onclose=null}async start(transferFormat){if(transferFormat=transferFormat||TransferFormat.Binary,Arg.isIn(transferFormat,TransferFormat,"transferFormat"),this._logger.log(LogLevel.Debug,`Starting connection with transfer format '${TransferFormat[transferFormat]}'.`),"Disconnected"!==this._connectionState)return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."));if(this._connectionState="Connecting",this._startInternalPromise=this._startInternal(transferFormat),await this._startInternalPromise,"Disconnecting"===this._connectionState){const message="Failed to start the HttpConnection before stop() was called.";return this._logger.log(LogLevel.Error,message),await this._stopPromise,Promise.reject(new AbortError(message))}if("Connected"!==this._connectionState){const message="HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";return this._logger.log(LogLevel.Error,message),Promise.reject(new AbortError(message))}this._connectionStarted=!0}send(data){return"Connected"!==this._connectionState?Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")):(this._sendQueue||(this._sendQueue=new TransportSendQueue(this.transport)),this._sendQueue.send(data))}async stop(error){return"Disconnected"===this._connectionState?(this._logger.log(LogLevel.Debug,`Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnected state.`),Promise.resolve()):"Disconnecting"===this._connectionState?(this._logger.log(LogLevel.Debug,`Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`),this._stopPromise):(this._connectionState="Disconnecting",this._stopPromise=new Promise(resolve=>{this._stopPromiseResolver=resolve}),await this._stopInternal(error),void await this._stopPromise)}async _stopInternal(error){this._stopError=error;try{await this._startInternalPromise}catch(e){}if(this.transport){try{await this.transport.stop()}catch(e){this._logger.log(LogLevel.Error,`HttpConnection.transport.stop() threw error '${e}'.`),this._stopConnection()}this.transport=void 0}else this._logger.log(LogLevel.Debug,"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.")}async _startInternal(transferFormat){let url=this.baseUrl;this._accessTokenFactory=this._options.accessTokenFactory,this._httpClient._accessTokenFactory=this._accessTokenFactory;try{if(this._options.skipNegotiation){if(this._options.transport!==HttpTransportType.WebSockets)throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");this.transport=this._constructTransport(HttpTransportType.WebSockets),await this._startTransport(url,transferFormat)}else{let negotiateResponse=null,redirects=0;do{if(negotiateResponse=await this._getNegotiationResponse(url),"Disconnecting"===this._connectionState||"Disconnected"===this._connectionState)throw new AbortError("The connection was stopped during negotiation.");if(negotiateResponse.error)throw new Error(negotiateResponse.error);if(negotiateResponse.ProtocolVersion)throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");if(negotiateResponse.url&&(url=negotiateResponse.url),negotiateResponse.accessToken){const accessToken=negotiateResponse.accessToken;this._accessTokenFactory=()=>accessToken,this._httpClient._accessToken=accessToken,this._httpClient._accessTokenFactory=void 0}redirects++}while(negotiateResponse.url&&redirects<100);if(100===redirects&&negotiateResponse.url)throw new Error("Negotiate redirection limit exceeded.");await this._createTransport(url,this._options.transport,negotiateResponse,transferFormat)}this.transport instanceof LongPollingTransport&&(this.features.inherentKeepAlive=!0),"Connecting"===this._connectionState&&(this._logger.log(LogLevel.Debug,"The HttpConnection connected successfully."),this._connectionState="Connected")}catch(e){return this._logger.log(LogLevel.Error,"Failed to start the connection: "+e),this._connectionState="Disconnected",this.transport=void 0,this._stopPromiseResolver(),Promise.reject(e)}}async _getNegotiationResponse(url){const headers={},[name,value]=getUserAgentHeader();headers[name]=value;const negotiateUrl=this._resolveNegotiateUrl(url);this._logger.log(LogLevel.Debug,`Sending negotiation request: ${negotiateUrl}.`);try{const response=await this._httpClient.post(negotiateUrl,{content:"",headers:{...headers,...this._options.headers},timeout:this._options.timeout,withCredentials:this._options.withCredentials});if(200!==response.statusCode)return Promise.reject(new Error(`Unexpected status code returned from negotiate '${response.statusCode}'`));const negotiateResponse=JSON.parse(response.content);return(!negotiateResponse.negotiateVersion||negotiateResponse.negotiateVersion<1)&&(negotiateResponse.connectionToken=negotiateResponse.connectionId),negotiateResponse.useStatefulReconnect&&!0!==this._options._useStatefulReconnect?Promise.reject(new FailedToNegotiateWithServerError("Client didn't negotiate Stateful Reconnect but the server did.")):negotiateResponse}catch(e){let errorMessage="Failed to complete negotiation with the server: "+e;return e instanceof HttpError&&404===e.statusCode&&(errorMessage+=" Either this is not a SignalR endpoint or there is a proxy blocking the connection."),this._logger.log(LogLevel.Error,errorMessage),Promise.reject(new FailedToNegotiateWithServerError(errorMessage))}}_createConnectUrl(url,connectionToken){return connectionToken?url+(-1===url.indexOf("?")?"?":"&")+`id=${connectionToken}`:url}async _createTransport(url,requestedTransport,negotiateResponse,requestedTransferFormat){let connectUrl=this._createConnectUrl(url,negotiateResponse.connectionToken);if(this._isITransport(requestedTransport))return this._logger.log(LogLevel.Debug,"Connection was provided an instance of ITransport, using that directly."),this.transport=requestedTransport,await this._startTransport(connectUrl,requestedTransferFormat),void(this.connectionId=negotiateResponse.connectionId);const transportExceptions=[],transports=negotiateResponse.availableTransports||[];let negotiate=negotiateResponse;for(const endpoint of transports){const transportOrError=this._resolveTransportOrError(endpoint,requestedTransport,requestedTransferFormat,!0===(null==negotiate?void 0:negotiate.useStatefulReconnect));if(transportOrError instanceof Error)transportExceptions.push(`${endpoint.transport} failed:`),transportExceptions.push(transportOrError);else if(this._isITransport(transportOrError)){if(this.transport=transportOrError,!negotiate){try{negotiate=await this._getNegotiationResponse(url)}catch(ex){return Promise.reject(ex)}connectUrl=this._createConnectUrl(url,negotiate.connectionToken)}try{return await this._startTransport(connectUrl,requestedTransferFormat),void(this.connectionId=negotiate.connectionId)}catch(ex){if(this._logger.log(LogLevel.Error,`Failed to start the transport '${endpoint.transport}': ${ex}`),negotiate=void 0,transportExceptions.push(new FailedToStartTransportError(`${endpoint.transport} failed: ${ex}`,HttpTransportType[endpoint.transport])),"Connecting"!==this._connectionState){const message="Failed to select transport before stop() was called.";return this._logger.log(LogLevel.Debug,message),Promise.reject(new AbortError(message))}}}}return transportExceptions.length>0?Promise.reject(new AggregateErrors(`Unable to connect to the server with any of the available transports. ${transportExceptions.join(" ")}`,transportExceptions)):Promise.reject(new Error("None of the transports supported by the client are supported by the server."))}_constructTransport(transport){switch(transport){case HttpTransportType.WebSockets:if(!this._options.WebSocket)throw new Error("'WebSocket' is not supported in your environment.");return new WebSocketTransport(this._httpClient,this._accessTokenFactory,this._logger,this._options.logMessageContent,this._options.WebSocket,this._options.headers||{});case HttpTransportType.ServerSentEvents:if(!this._options.EventSource)throw new Error("'EventSource' is not supported in your environment.");return new ServerSentEventsTransport(this._httpClient,this._httpClient._accessToken,this._logger,this._options);case HttpTransportType.LongPolling:return new LongPollingTransport(this._httpClient,this._logger,this._options);default:throw new Error(`Unknown transport: ${transport}.`)}}_startTransport(url,transferFormat){return this.transport.onreceive=this.onreceive,this.features.reconnect?this.transport.onclose=async e=>{let callStop=!1;if(this.features.reconnect){try{this.features.disconnected(),await this.transport.connect(url,transferFormat),await this.features.resend()}catch{callStop=!0}callStop&&this._stopConnection(e)}else this._stopConnection(e)}:this.transport.onclose=e=>this._stopConnection(e),this.transport.connect(url,transferFormat)}_resolveTransportOrError(endpoint,requestedTransport,requestedTransferFormat,useStatefulReconnect){const transport=HttpTransportType[endpoint.transport];if(null==transport)return this._logger.log(LogLevel.Debug,`Skipping transport '${endpoint.transport}' because it is not supported by this client.`),new Error(`Skipping transport '${endpoint.transport}' because it is not supported by this client.`);if(!function transportMatches(requestedTransport,actualTransport){return!requestedTransport||0!==(actualTransport&requestedTransport)}(requestedTransport,transport))return this._logger.log(LogLevel.Debug,`Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`),new DisabledTransportError(`'${HttpTransportType[transport]}' is disabled by the client.`,transport);if(!(endpoint.transferFormats.map(s=>TransferFormat[s]).indexOf(requestedTransferFormat)>=0))return this._logger.log(LogLevel.Debug,`Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`),new Error(`'${HttpTransportType[transport]}' does not support ${TransferFormat[requestedTransferFormat]}.`);if(transport===HttpTransportType.WebSockets&&!this._options.WebSocket||transport===HttpTransportType.ServerSentEvents&&!this._options.EventSource)return this._logger.log(LogLevel.Debug,`Skipping transport '${HttpTransportType[transport]}' because it is not supported in your environment.'`),new UnsupportedTransportError(`'${HttpTransportType[transport]}' is not supported in your environment.`,transport);this._logger.log(LogLevel.Debug,`Selecting transport '${HttpTransportType[transport]}'.`);try{return this.features.reconnect=transport===HttpTransportType.WebSockets?useStatefulReconnect:void 0,this._constructTransport(transport)}catch(ex){return ex}}_isITransport(transport){return transport&&"object"==typeof transport&&"connect"in transport}_stopConnection(error){if(this._logger.log(LogLevel.Debug,`HttpConnection.stopConnection(${error}) called while in state ${this._connectionState}.`),this.transport=void 0,error=this._stopError||error,this._stopError=void 0,"Disconnected"!==this._connectionState){if("Connecting"===this._connectionState)throw this._logger.log(LogLevel.Warning,`Call to HttpConnection.stopConnection(${error}) was ignored because the connection is still in the connecting state.`),new Error(`HttpConnection.stopConnection(${error}) was called while the connection is still in the connecting state.`);if("Disconnecting"===this._connectionState&&this._stopPromiseResolver(),error?this._logger.log(LogLevel.Error,`Connection disconnected with error '${error}'.`):this._logger.log(LogLevel.Information,"Connection disconnected."),this._sendQueue&&(this._sendQueue.stop().catch(e=>{this._logger.log(LogLevel.Error,`TransportSendQueue.stop() threw error '${e}'.`)}),this._sendQueue=void 0),this.connectionId=void 0,this._connectionState="Disconnected",this._connectionStarted){this._connectionStarted=!1;try{this.onclose&&this.onclose(error)}catch(e){this._logger.log(LogLevel.Error,`HttpConnection.onclose(${error}) threw error '${e}'.`)}}}else this._logger.log(LogLevel.Debug,`Call to HttpConnection.stopConnection(${error}) was ignored because the connection is already in the disconnected state.`)}_resolveUrl(url){if(0===url.lastIndexOf("https://",0)||0===url.lastIndexOf("http://",0))return url;if(!Platform.isBrowser)throw new Error(`Cannot resolve '${url}'.`);const aTag=window.document.createElement("a");return aTag.href=url,this._logger.log(LogLevel.Information,`Normalizing '${url}' to '${aTag.href}'.`),aTag.href}_resolveNegotiateUrl(url){const negotiateUrl=new URL(url);negotiateUrl.pathname.endsWith("/")?negotiateUrl.pathname+="negotiate":negotiateUrl.pathname+="/negotiate";const searchParams=new URLSearchParams(negotiateUrl.searchParams);return searchParams.has("negotiateVersion")||searchParams.append("negotiateVersion",this._negotiateVersion.toString()),searchParams.has("useStatefulReconnect")?"true"===searchParams.get("useStatefulReconnect")&&(this._options._useStatefulReconnect=!0):!0===this._options._useStatefulReconnect&&searchParams.append("useStatefulReconnect","true"),negotiateUrl.search=searchParams.toString(),negotiateUrl.toString()}}class TransportSendQueue{constructor(_transport){this._transport=_transport,this._buffer=[],this._executing=!0,this._sendBufferedData=new PromiseSource,this._transportResult=new PromiseSource,this._sendLoopPromise=this._sendLoop()}send(data){return this._bufferData(data),this._transportResult||(this._transportResult=new PromiseSource),this._transportResult.promise}stop(){return this._executing=!1,this._sendBufferedData.resolve(),this._sendLoopPromise}_bufferData(data){if(this._buffer.length&&typeof this._buffer[0]!=typeof data)throw new Error(`Expected data to be of type ${typeof this._buffer} but was of type ${typeof data}`);this._buffer.push(data),this._sendBufferedData.resolve()}async _sendLoop(){for(;;){if(await this._sendBufferedData.promise,!this._executing){this._transportResult&&this._transportResult.reject("Connection stopped.");break}this._sendBufferedData=new PromiseSource;const transportResult=this._transportResult;this._transportResult=void 0;const data="string"==typeof this._buffer[0]?this._buffer.join(""):TransportSendQueue._concatBuffers(this._buffer);this._buffer.length=0;try{await this._transport.send(data),transportResult.resolve()}catch(error){transportResult.reject(error)}}}static _concatBuffers(arrayBuffers){const totalLength=arrayBuffers.map(b=>b.byteLength).reduce((a,b)=>a+b),result=new Uint8Array(totalLength);let offset=0;for(const item of arrayBuffers)result.set(new Uint8Array(item),offset),offset+=item.byteLength;return result.buffer}}class PromiseSource{constructor(){this.promise=new Promise((resolve,reject)=>[this._resolver,this._rejecter]=[resolve,reject])}resolve(){this._resolver()}reject(reason){this._rejecter(reason)}}class TextMessageFormat{static write(output){return`${output}${TextMessageFormat.RecordSeparator}`}static parse(input){if(input[input.length-1]!==TextMessageFormat.RecordSeparator)throw new Error("Message is incomplete.");const messages=input.split(TextMessageFormat.RecordSeparator);return messages.pop(),messages}}TextMessageFormat.RecordSeparatorCode=30,TextMessageFormat.RecordSeparator=String.fromCharCode(TextMessageFormat.RecordSeparatorCode);class HandshakeProtocol{writeHandshakeRequest(handshakeRequest){return TextMessageFormat.write(JSON.stringify(handshakeRequest))}parseHandshakeResponse(data){let messageData,remainingData;if(isArrayBuffer(data)){const binaryData=new Uint8Array(data),separatorIndex=binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);if(-1===separatorIndex)throw new Error("Message is incomplete.");const responseLength=separatorIndex+1;messageData=String.fromCharCode.apply(null,Array.prototype.slice.call(binaryData.slice(0,responseLength))),remainingData=binaryData.byteLength>responseLength?binaryData.slice(responseLength).buffer:null}else{const textData=data,separatorIndex=textData.indexOf(TextMessageFormat.RecordSeparator);if(-1===separatorIndex)throw new Error("Message is incomplete.");const responseLength=separatorIndex+1;messageData=textData.substring(0,responseLength),remainingData=textData.length>responseLength?textData.substring(responseLength):null}const messages=TextMessageFormat.parse(messageData),response=JSON.parse(messages[0]);if(response.type)throw new Error("Expected a handshake response from the server.");return[remainingData,response]}}var MessageType;!function(MessageType){MessageType[MessageType.Invocation=1]="Invocation",MessageType[MessageType.StreamItem=2]="StreamItem",MessageType[MessageType.Completion=3]="Completion",MessageType[MessageType.StreamInvocation=4]="StreamInvocation",MessageType[MessageType.CancelInvocation=5]="CancelInvocation",MessageType[MessageType.Ping=6]="Ping",MessageType[MessageType.Close=7]="Close",MessageType[MessageType.Ack=8]="Ack",MessageType[MessageType.Sequence=9]="Sequence"}(MessageType||(MessageType={}));class Subject{constructor(){this.observers=[]}next(item){for(const observer of this.observers)observer.next(item)}error(err){for(const observer of this.observers)observer.error&&observer.error(err)}complete(){for(const observer of this.observers)observer.complete&&observer.complete()}subscribe(observer){return this.observers.push(observer),new SubjectSubscription(this,observer)}}class MessageBuffer{constructor(protocol,connection,bufferSize){this._bufferSize=1e5,this._messages=[],this._totalMessageCount=0,this._waitForSequenceMessage=!1,this._nextReceivingSequenceId=1,this._latestReceivedSequenceId=0,this._bufferedByteCount=0,this._reconnectInProgress=!1,this._protocol=protocol,this._connection=connection,this._bufferSize=bufferSize}async _send(message){const serializedMessage=this._protocol.writeMessage(message);let backpressurePromise=Promise.resolve();if(this._isInvocationMessage(message)){this._totalMessageCount++;let backpressurePromiseResolver=()=>{},backpressurePromiseRejector=()=>{};isArrayBuffer(serializedMessage)?this._bufferedByteCount+=serializedMessage.byteLength:this._bufferedByteCount+=serializedMessage.length,this._bufferedByteCount>=this._bufferSize&&(backpressurePromise=new Promise((resolve,reject)=>{backpressurePromiseResolver=resolve,backpressurePromiseRejector=reject})),this._messages.push(new BufferedItem(serializedMessage,this._totalMessageCount,backpressurePromiseResolver,backpressurePromiseRejector))}try{this._reconnectInProgress||await this._connection.send(serializedMessage)}catch{this._disconnected()}await backpressurePromise}_ack(ackMessage){let newestAckedMessage=-1;for(let index=0;index<this._messages.length;index++){const element=this._messages[index];if(element._id<=ackMessage.sequenceId)newestAckedMessage=index,isArrayBuffer(element._message)?this._bufferedByteCount-=element._message.byteLength:this._bufferedByteCount-=element._message.length,element._resolver();else{if(!(this._bufferedByteCount<this._bufferSize))break;element._resolver()}}-1!==newestAckedMessage&&(this._messages=this._messages.slice(newestAckedMessage+1))}_shouldProcessMessage(message){if(this._waitForSequenceMessage)return message.type===MessageType.Sequence&&(this._waitForSequenceMessage=!1,!0);if(!this._isInvocationMessage(message))return!0;const currentId=this._nextReceivingSequenceId;return this._nextReceivingSequenceId++,currentId<=this._latestReceivedSequenceId?(currentId===this._latestReceivedSequenceId&&this._ackTimer(),!1):(this._latestReceivedSequenceId=currentId,this._ackTimer(),!0)}_resetSequence(message){message.sequenceId>this._nextReceivingSequenceId?this._connection.stop(new Error("Sequence ID greater than amount of messages we've received.")):this._nextReceivingSequenceId=message.sequenceId}_disconnected(){this._reconnectInProgress=!0,this._waitForSequenceMessage=!0}async _resend(){const sequenceId=0!==this._messages.length?this._messages[0]._id:this._totalMessageCount+1;await this._connection.send(this._protocol.writeMessage({type:MessageType.Sequence,sequenceId}));const messages=this._messages;for(const element of messages)await this._connection.send(element._message);this._reconnectInProgress=!1}_dispose(error){null!=error||(error=new Error("Unable to reconnect to server."));for(const element of this._messages)element._rejector(error)}_isInvocationMessage(message){switch(message.type){case MessageType.Invocation:case MessageType.StreamItem:case MessageType.Completion:case MessageType.StreamInvocation:case MessageType.CancelInvocation:return!0;case MessageType.Close:case MessageType.Sequence:case MessageType.Ping:case MessageType.Ack:return!1}}_ackTimer(){void 0===this._ackTimerHandle&&(this._ackTimerHandle=setTimeout(async()=>{try{this._reconnectInProgress||await this._connection.send(this._protocol.writeMessage({type:MessageType.Ack,sequenceId:this._latestReceivedSequenceId}))}catch{}clearTimeout(this._ackTimerHandle),this._ackTimerHandle=void 0},1e3))}}class BufferedItem{constructor(message,id,resolver,rejector){this._message=message,this._id=id,this._resolver=resolver,this._rejector=rejector}}var HubConnectionState;!function(HubConnectionState){HubConnectionState.Disconnected="Disconnected",HubConnectionState.Connecting="Connecting",HubConnectionState.Connected="Connected",HubConnectionState.Disconnecting="Disconnecting",HubConnectionState.Reconnecting="Reconnecting"}(HubConnectionState||(HubConnectionState={}));class HubConnection{static create(connection,logger,protocol,reconnectPolicy,serverTimeoutInMilliseconds,keepAliveIntervalInMilliseconds,statefulReconnectBufferSize){return new HubConnection(connection,logger,protocol,reconnectPolicy,serverTimeoutInMilliseconds,keepAliveIntervalInMilliseconds,statefulReconnectBufferSize)}constructor(connection,logger,protocol,reconnectPolicy,serverTimeoutInMilliseconds,keepAliveIntervalInMilliseconds,statefulReconnectBufferSize){this._nextKeepAlive=0,this._freezeEventListener=()=>{this._logger.log(LogLevel.Warning,"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep")},Arg.isRequired(connection,"connection"),Arg.isRequired(logger,"logger"),Arg.isRequired(protocol,"protocol"),this.serverTimeoutInMilliseconds=null!=serverTimeoutInMilliseconds?serverTimeoutInMilliseconds:3e4,this.keepAliveIntervalInMilliseconds=null!=keepAliveIntervalInMilliseconds?keepAliveIntervalInMilliseconds:15e3,this._statefulReconnectBufferSize=null!=statefulReconnectBufferSize?statefulReconnectBufferSize:1e5,this._logger=logger,this._protocol=protocol,this.connection=connection,this._reconnectPolicy=reconnectPolicy,this._handshakeProtocol=new HandshakeProtocol,this.connection.onreceive=data=>this._processIncomingData(data),this.connection.onclose=error=>this._connectionClosed(error),this._callbacks={},this._methods={},this._closedCallbacks=[],this._reconnectingCallbacks=[],this._reconnectedCallbacks=[],this._invocationId=0,this._receivedHandshakeResponse=!1,this._connectionState=HubConnectionState.Disconnected,this._connectionStarted=!1,this._cachedPingMessage=this._protocol.writeMessage({type:MessageType.Ping})}get state(){return this._connectionState}get connectionId(){return this.connection&&this.connection.connectionId||null}get baseUrl(){return this.connection.baseUrl||""}set baseUrl(url){if(this._connectionState!==HubConnectionState.Disconnected&&this._connectionState!==HubConnectionState.Reconnecting)throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");if(!url)throw new Error("The HubConnection url must be a valid url.");this.connection.baseUrl=url}start(){return this._startPromise=this._startWithStateTransitions(),this._startPromise}async _startWithStateTransitions(){if(this._connectionState!==HubConnectionState.Disconnected)return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));this._connectionState=HubConnectionState.Connecting,this._logger.log(LogLevel.Debug,"Starting HubConnection.");try{await this._startInternal(),Platform.isBrowser&&window.document.addEventListener("freeze",this._freezeEventListener),this._connectionState=HubConnectionState.Connected,this._connectionStarted=!0,this._logger.log(LogLevel.Debug,"HubConnection connected successfully.")}catch(e){return this._connectionState=HubConnectionState.Disconnected,this._logger.log(LogLevel.Debug,`HubConnection failed to start successfully because of error '${e}'.`),Promise.reject(e)}}async _startInternal(){this._stopDuringStartError=void 0,this._receivedHandshakeResponse=!1;const handshakePromise=new Promise((resolve,reject)=>{this._handshakeResolver=resolve,this._handshakeRejecter=reject});await this.connection.start(this._protocol.transferFormat);try{let version=this._protocol.version;this.connection.features.reconnect||(version=1);const handshakeRequest={protocol:this._protocol.name,version};if(this._logger.log(LogLevel.Debug,"Sending handshake request."),await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(handshakeRequest)),this._logger.log(LogLevel.Information,`Using HubProtocol '${this._protocol.name}'.`),this._cleanupTimeout(),this._resetTimeoutPeriod(),this._resetKeepAliveInterval(),await handshakePromise,this._stopDuringStartError)throw this._stopDuringStartError;(this.connection.features.reconnect||!1)&&(this._messageBuffer=new MessageBuffer(this._protocol,this.connection,this._statefulReconnectBufferSize),this.connection.features.disconnected=this._messageBuffer._disconnected.bind(this._messageBuffer),this.connection.features.resend=()=>{if(this._messageBuffer)return this._messageBuffer._resend()}),this.connection.features.inherentKeepAlive||await this._sendMessage(this._cachedPingMessage)}catch(e){throw this._logger.log(LogLevel.Debug,`Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`),this._cleanupTimeout(),this._cleanupPingTimer(),await this.connection.stop(e),e}}async stop(){const startPromise=this._startPromise;this.connection.features.reconnect=!1,this._stopPromise=this._stopInternal(),await this._stopPromise;try{await startPromise}catch(e){}}_stopInternal(error){if(this._connectionState===HubConnectionState.Disconnected)return this._logger.log(LogLevel.Debug,`Call to HubConnection.stop(${error}) ignored because it is already in the disconnected state.`),Promise.resolve();if(this._connectionState===HubConnectionState.Disconnecting)return this._logger.log(LogLevel.Debug,`Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`),this._stopPromise;const state=this._connectionState;return this._connectionState=HubConnectionState.Disconnecting,this._logger.log(LogLevel.Debug,"Stopping HubConnection."),this._reconnectDelayHandle?(this._logger.log(LogLevel.Debug,"Connection stopped during reconnect delay. Done reconnecting."),clearTimeout(this._reconnectDelayHandle),this._reconnectDelayHandle=void 0,this._completeClose(),Promise.resolve()):(state===HubConnectionState.Connected&&this._sendCloseMessage(),this._cleanupTimeout(),this._cleanupPingTimer(),this._stopDuringStartError=error||new AbortError("The connection was stopped before the hub handshake could complete."),this.connection.stop(error))}async _sendCloseMessage(){try{await this._sendWithProtocol(this._createCloseMessage())}catch{}}stream(methodName,...args){const[streams,streamIds]=this._replaceStreamingParams(args),invocationDescriptor=this._createStreamInvocation(methodName,args,streamIds);let promiseQueue;const subject=new Subject;return subject.cancelCallback=()=>{const cancelInvocation=this._createCancelInvocation(invocationDescriptor.invocationId);return delete this._callbacks[invocationDescriptor.invocationId],promiseQueue.then(()=>this._sendWithProtocol(cancelInvocation))},this._callbacks[invocationDescriptor.invocationId]=(invocationEvent,error)=>{error?subject.error(error):invocationEvent&&(invocationEvent.type===MessageType.Completion?invocationEvent.error?subject.error(new Error(invocationEvent.error)):subject.complete():subject.next(invocationEvent.item))},promiseQueue=this._sendWithProtocol(invocationDescriptor).catch(e=>{subject.error(e),delete this._callbacks[invocationDescriptor.invocationId]}),this._launchStreams(streams,promiseQueue),subject}_sendMessage(message){return this._resetKeepAliveInterval(),this.connection.send(message)}_sendWithProtocol(message){return this._messageBuffer?this._messageBuffer._send(message):this._sendMessage(this._protocol.writeMessage(message))}send(methodName,...args){const[streams,streamIds]=this._replaceStreamingParams(args),sendPromise=this._sendWithProtocol(this._createInvocation(methodName,args,!0,streamIds));return this._launchStreams(streams,sendPromise),sendPromise}invoke(methodName,...args){const[streams,streamIds]=this._replaceStreamingParams(args),invocationDescriptor=this._createInvocation(methodName,args,!1,streamIds);return new Promise((resolve,reject)=>{this._callbacks[invocationDescriptor.invocationId]=(invocationEvent,error)=>{error?reject(error):invocationEvent&&(invocationEvent.type===MessageType.Completion?invocationEvent.error?reject(new Error(invocationEvent.error)):resolve(invocationEvent.result):reject(new Error(`Unexpected message type: ${invocationEvent.type}`)))};const promiseQueue=this._sendWithProtocol(invocationDescriptor).catch(e=>{reject(e),delete this._callbacks[invocationDescriptor.invocationId]});this._launchStreams(streams,promiseQueue)})}on(methodName,newMethod){methodName&&newMethod&&(methodName=methodName.toLowerCase(),this._methods[methodName]||(this._methods[methodName]=[]),-1===this._methods[methodName].indexOf(newMethod)&&this._methods[methodName].push(newMethod))}off(methodName,method){if(!methodName)return;methodName=methodName.toLowerCase();const handlers=this._methods[methodName];if(handlers)if(method){const removeIdx=handlers.indexOf(method);-1!==removeIdx&&(handlers.splice(removeIdx,1),0===handlers.length&&delete this._methods[methodName])}else delete this._methods[methodName]}onclose(callback){callback&&this._closedCallbacks.push(callback)}onreconnecting(callback){callback&&this._reconnectingCallbacks.push(callback)}onreconnected(callback){callback&&this._reconnectedCallbacks.push(callback)}_processIncomingData(data){if(this._cleanupTimeout(),this._receivedHandshakeResponse||(data=this._processHandshakeResponse(data),this._receivedHandshakeResponse=!0),data){const messages=this._protocol.parseMessages(data,this._logger);for(const message of messages)if(!this._messageBuffer||this._messageBuffer._shouldProcessMessage(message))switch(message.type){case MessageType.Invocation:this._invokeClientMethod(message).catch(e=>{this._logger.log(LogLevel.Error,`Invoke client method threw error: ${getErrorString(e)}`)});break;case MessageType.StreamItem:case MessageType.Completion:{const callback=this._callbacks[message.invocationId];if(callback){message.type===MessageType.Completion&&delete this._callbacks[message.invocationId];try{callback(message)}catch(e){this._logger.log(LogLevel.Error,`Stream callback threw error: ${getErrorString(e)}`)}}break}case MessageType.Ping:break;case MessageType.Close:{this._logger.log(LogLevel.Information,"Close message received from server.");const error=message.error?new Error("Server returned an error on close: "+message.error):void 0;!0===message.allowReconnect?this.connection.stop(error):this._stopPromise=this._stopInternal(error);break}case MessageType.Ack:this._messageBuffer&&this._messageBuffer._ack(message);break;case MessageType.Sequence:this._messageBuffer&&this._messageBuffer._resetSequence(message);break;default:this._logger.log(LogLevel.Warning,`Invalid message type: ${message.type}.`)}}this._resetTimeoutPeriod()}_processHandshakeResponse(data){let responseMessage,remainingData;try{[remainingData,responseMessage]=this._handshakeProtocol.parseHandshakeResponse(data)}catch(e){const message="Error parsing handshake response: "+e;this._logger.log(LogLevel.Error,message);const error=new Error(message);throw this._handshakeRejecter(error),error}if(responseMessage.error){const message="Server returned handshake error: "+responseMessage.error;this._logger.log(LogLevel.Error,message);const error=new Error(message);throw this._handshakeRejecter(error),error}return this._logger.log(LogLevel.Debug,"Server handshake complete."),this._handshakeResolver(),remainingData}_resetKeepAliveInterval(){this.connection.features.inherentKeepAlive||(this._nextKeepAlive=(new Date).getTime()+this.keepAliveIntervalInMilliseconds,this._cleanupPingTimer())}_resetTimeoutPeriod(){if(!this.connection.features||!this.connection.features.inherentKeepAlive){this._timeoutHandle=setTimeout(()=>this.serverTimeout(),this.serverTimeoutInMilliseconds);let nextPing=this._nextKeepAlive-(new Date).getTime();if(nextPing<0)return void(this._connectionState===HubConnectionState.Connected&&this._trySendPingMessage());void 0===this._pingServerHandle&&(nextPing<0&&(nextPing=0),this._pingServerHandle=setTimeout(async()=>{this._connectionState===HubConnectionState.Connected&&await this._trySendPingMessage()},nextPing))}}serverTimeout(){this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."))}async _invokeClientMethod(invocationMessage){const methodName=invocationMessage.target.toLowerCase(),methods=this._methods[methodName];if(!methods)return this._logger.log(LogLevel.Warning,`No client method with the name '${methodName}' found.`),void(invocationMessage.invocationId&&(this._logger.log(LogLevel.Warning,`No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`),await this._sendWithProtocol(this._createCompletionMessage(invocationMessage.invocationId,"Client didn't provide a result.",null))));const methodsCopy=methods.slice(),expectsResponse=!!invocationMessage.invocationId;let res,exception,completionMessage;for(const m of methodsCopy)try{const prevRes=res;res=await m.apply(this,invocationMessage.arguments),expectsResponse&&res&&prevRes&&(this._logger.log(LogLevel.Error,`Multiple results provided for '${methodName}'. Sending error to server.`),completionMessage=this._createCompletionMessage(invocationMessage.invocationId,"Client provided multiple results.",null)),exception=void 0}catch(e){exception=e,this._logger.log(LogLevel.Error,`A callback for the method '${methodName}' threw error '${e}'.`)}completionMessage?await this._sendWithProtocol(completionMessage):expectsResponse?(exception?completionMessage=this._createCompletionMessage(invocationMessage.invocationId,`${exception}`,null):void 0!==res?completionMessage=this._createCompletionMessage(invocationMessage.invocationId,null,res):(this._logger.log(LogLevel.Warning,`No result given for '${methodName}' method and invocation ID '${invocationMessage.invocationId}'.`),completionMessage=this._createCompletionMessage(invocationMessage.invocationId,"Client didn't provide a result.",null)),await this._sendWithProtocol(completionMessage)):res&&this._logger.log(LogLevel.Error,`Result given for '${methodName}' method but server is not expecting a result.`)}_connectionClosed(error){this._logger.log(LogLevel.Debug,`HubConnection.connectionClosed(${error}) called while in state ${this._connectionState}.`),this._stopDuringStartError=this._stopDuringStartError||error||new AbortError("The underlying connection was closed before the hub handshake could complete."),this._handshakeResolver&&this._handshakeResolver(),this._cancelCallbacksWithError(error||new Error("Invocation canceled due to the underlying connection being closed.")),this._cleanupTimeout(),this._cleanupPingTimer(),this._connectionState===HubConnectionState.Disconnecting?this._completeClose(error):this._connectionState===HubConnectionState.Connected&&this._reconnectPolicy?this._reconnect(error):this._connectionState===HubConnectionState.Connected&&this._completeClose(error)}_completeClose(error){if(this._connectionStarted){this._connectionState=HubConnectionState.Disconnected,this._connectionStarted=!1,this._messageBuffer&&(this._messageBuffer._dispose(null!=error?error:new Error("Connection closed.")),this._messageBuffer=void 0),Platform.isBrowser&&window.document.removeEventListener("freeze",this._freezeEventListener);try{this._closedCallbacks.forEach(c=>c.apply(this,[error]))}catch(e){this._logger.log(LogLevel.Error,`An onclose callback called with error '${error}' threw error '${e}'.`)}}}async _reconnect(error){const reconnectStartTime=Date.now();let previousReconnectAttempts=0,retryError=void 0!==error?error:new Error("Attempting to reconnect due to a unknown error."),nextRetryDelay=this._getNextRetryDelay(previousReconnectAttempts,0,retryError);if(null===nextRetryDelay)return this._logger.log(LogLevel.Debug,"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."),void this._completeClose(error);if(this._connectionState=HubConnectionState.Reconnecting,error?this._logger.log(LogLevel.Information,`Connection reconnecting because of error '${error}'.`):this._logger.log(LogLevel.Information,"Connection reconnecting."),0!==this._reconnectingCallbacks.length){try{this._reconnectingCallbacks.forEach(c=>c.apply(this,[error]))}catch(e){this._logger.log(LogLevel.Error,`An onreconnecting callback called with error '${error}' threw error '${e}'.`)}if(this._connectionState!==HubConnectionState.Reconnecting)return void this._logger.log(LogLevel.Debug,"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.")}for(;null!==nextRetryDelay;){if(this._logger.log(LogLevel.Information,`Reconnect attempt number ${previousReconnectAttempts+1} will start in ${nextRetryDelay} ms.`),await new Promise(resolve=>{this._reconnectDelayHandle=setTimeout(resolve,nextRetryDelay)}),this._reconnectDelayHandle=void 0,this._connectionState!==HubConnectionState.Reconnecting)return void this._logger.log(LogLevel.Debug,"Connection left the reconnecting state during reconnect delay. Done reconnecting.");try{if(await this._startInternal(),this._connectionState=HubConnectionState.Connected,this._logger.log(LogLevel.Information,"HubConnection reconnected successfully."),0!==this._reconnectedCallbacks.length)try{this._reconnectedCallbacks.forEach(c=>c.apply(this,[this.connection.connectionId]))}catch(e){this._logger.log(LogLevel.Error,`An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`)}return}catch(e){if(this._logger.log(LogLevel.Information,`Reconnect attempt failed because of error '${e}'.`),this._connectionState!==HubConnectionState.Reconnecting)return this._logger.log(LogLevel.Debug,`Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`),void(this._connectionState===HubConnectionState.Disconnecting&&this._completeClose());previousReconnectAttempts++,retryError=e instanceof Error?e:new Error(e.toString()),nextRetryDelay=this._getNextRetryDelay(previousReconnectAttempts,Date.now()-reconnectStartTime,retryError)}}this._logger.log(LogLevel.Information,`Reconnect retries have been exhausted after ${Date.now()-reconnectStartTime} ms and ${previousReconnectAttempts} failed attempts. Connection disconnecting.`),this._completeClose()}_getNextRetryDelay(previousRetryCount,elapsedMilliseconds,retryReason){try{return this._reconnectPolicy.nextRetryDelayInMilliseconds({elapsedMilliseconds,previousRetryCount,retryReason})}catch(e){return this._logger.log(LogLevel.Error,`IRetryPolicy.nextRetryDelayInMilliseconds(${previousRetryCount}, ${elapsedMilliseconds}) threw error '${e}'.`),null}}_cancelCallbacksWithError(error){const callbacks=this._callbacks;this._callbacks={},Object.keys(callbacks).forEach(key=>{const callback=callbacks[key];try{callback(null,error)}catch(e){this._logger.log(LogLevel.Error,`Stream 'error' callback called with '${error}' threw error: ${getErrorString(e)}`)}})}_cleanupPingTimer(){this._pingServerHandle&&(clearTimeout(this._pingServerHandle),this._pingServerHandle=void 0)}_cleanupTimeout(){this._timeoutHandle&&clearTimeout(this._timeoutHandle)}_createInvocation(methodName,args,nonblocking,streamIds){if(nonblocking)return 0!==streamIds.length?{target:methodName,arguments:args,streamIds,type:MessageType.Invocation}:{target:methodName,arguments:args,type:MessageType.Invocation};{const invocationId=this._invocationId;return this._invocationId++,0!==streamIds.length?{target:methodName,arguments:args,invocationId:invocationId.toString(),streamIds,type:MessageType.Invocation}:{target:methodName,arguments:args,invocationId:invocationId.toString(),type:MessageType.Invocation}}}_launchStreams(streams,promiseQueue){if(0!==streams.length){promiseQueue||(promiseQueue=Promise.resolve());for(const streamId in streams)streams[streamId].subscribe({complete:()=>{promiseQueue=promiseQueue.then(()=>this._sendWithProtocol(this._createCompletionMessage(streamId)))},error:err=>{let message;message=err instanceof Error?err.message:err&&err.toString?err.toString():"Unknown error",promiseQueue=promiseQueue.then(()=>this._sendWithProtocol(this._createCompletionMessage(streamId,message)))},next:item=>{promiseQueue=promiseQueue.then(()=>this._sendWithProtocol(this._createStreamItemMessage(streamId,item)))}})}}_replaceStreamingParams(args){const streams=[],streamIds=[];for(let i=0;i<args.length;i++){const argument=args[i];if(this._isObservable(argument)){const streamId=this._invocationId;this._invocationId++,streams[streamId]=argument,streamIds.push(streamId.toString()),args.splice(i,1)}}return[streams,streamIds]}_isObservable(arg){return arg&&arg.subscribe&&"function"==typeof arg.subscribe}_createStreamInvocation(methodName,args,streamIds){const invocationId=this._invocationId;return this._invocationId++,0!==streamIds.length?{target:methodName,arguments:args,invocationId:invocationId.toString(),streamIds,type:MessageType.StreamInvocation}:{target:methodName,arguments:args,invocationId:invocationId.toString(),type:MessageType.StreamInvocation}}_createCancelInvocation(id){return{invocationId:id,type:MessageType.CancelInvocation}}_createStreamItemMessage(id,item){return{invocationId:id,item,type:MessageType.StreamItem}}_createCompletionMessage(id,error,result){return error?{error,invocationId:id,type:MessageType.Completion}:{invocationId:id,result,type:MessageType.Completion}}_createCloseMessage(){return{type:MessageType.Close}}async _trySendPingMessage(){try{await this._sendMessage(this._cachedPingMessage)}catch{this._cleanupPingTimer()}}}class JsonHubProtocol{constructor(){this.name="json",this.version=2,this.transferFormat=TransferFormat.Text}parseMessages(input,logger){if("string"!=typeof input)throw new Error("Invalid input for JSON hub protocol. Expected a string.");if(!input)return[];null===logger&&(logger=NullLogger.instance);const messages=TextMessageFormat.parse(input),hubMessages=[];for(const message of messages){const parsedMessage=JSON.parse(message);if("number"!=typeof parsedMessage.type)throw new Error("Invalid payload.");switch(parsedMessage.type){case MessageType.Invocation:this._isInvocationMessage(parsedMessage);break;case MessageType.StreamItem:this._isStreamItemMessage(parsedMessage);break;case MessageType.Completion:this._isCompletionMessage(parsedMessage);break;case MessageType.Ping:case MessageType.Close:break;case MessageType.Ack:this._isAckMessage(parsedMessage);break;case MessageType.Sequence:this._isSequenceMessage(parsedMessage);break;default:logger.log(LogLevel.Information,"Unknown message type '"+parsedMessage.type+"' ignored.");continue}hubMessages.push(parsedMessage)}return hubMessages}writeMessage(message){return TextMessageFormat.write(JSON.stringify(message))}_isInvocationMessage(message){this._assertNotEmptyString(message.target,"Invalid payload for Invocation message."),void 0!==message.invocationId&&this._assertNotEmptyString(message.invocationId,"Invalid payload for Invocation message.")}_isStreamItemMessage(message){if(this._assertNotEmptyString(message.invocationId,"Invalid payload for StreamItem message."),void 0===message.item)throw new Error("Invalid payload for StreamItem message.")}_isCompletionMessage(message){if(message.result&&message.error)throw new Error("Invalid payload for Completion message.");!message.result&&message.error&&this._assertNotEmptyString(message.error,"Invalid payload for Completion message."),this._assertNotEmptyString(message.invocationId,"Invalid payload for Completion message.")}_isAckMessage(message){if("number"!=typeof message.sequenceId)throw new Error("Invalid SequenceId for Ack message.")}_isSequenceMessage(message){if("number"!=typeof message.sequenceId)throw new Error("Invalid SequenceId for Sequence message.")}_assertNotEmptyString(value,errorMessage){if("string"!=typeof value||""===value)throw new Error(errorMessage)}}const LogLevelNameMapping={trace:LogLevel.Trace,debug:LogLevel.Debug,info:LogLevel.Information,information:LogLevel.Information,warn:LogLevel.Warning,warning:LogLevel.Warning,error:LogLevel.Error,critical:LogLevel.Critical,none:LogLevel.None};class HubConnectionBuilder{configureLogging(logging){if(Arg.isRequired(logging,"logging"),function isLogger(logger){return void 0!==logger.log}(logging))this.logger=logging;else if("string"==typeof logging){const logLevel=function parseLogLevel(name){const mapping=LogLevelNameMapping[name.toLowerCase()];if(void 0!==mapping)return mapping;throw new Error(`Unknown log level: ${name}`)}(logging);this.logger=new ConsoleLogger(logLevel)}else this.logger=new ConsoleLogger(logging);return this}withUrl(url,transportTypeOrOptions){return Arg.isRequired(url,"url"),Arg.isNotEmpty(url,"url"),this.url=url,this.httpConnectionOptions="object"==typeof transportTypeOrOptions?{...this.httpConnectionOptions,...transportTypeOrOptions}:{...this.httpConnectionOptions,transport:transportTypeOrOptions},this}withHubProtocol(protocol){return Arg.isRequired(protocol,"protocol"),this.protocol=protocol,this}withAutomaticReconnect(retryDelaysOrReconnectPolicy){if(this.reconnectPolicy)throw new Error("A reconnectPolicy has already been set.");return retryDelaysOrReconnectPolicy?Array.isArray(retryDelaysOrReconnectPolicy)?this.reconnectPolicy=new DefaultReconnectPolicy(retryDelaysOrReconnectPolicy):this.reconnectPolicy=retryDelaysOrReconnectPolicy:this.reconnectPolicy=new DefaultReconnectPolicy,this}withServerTimeout(milliseconds){return Arg.isRequired(milliseconds,"milliseconds"),this._serverTimeoutInMilliseconds=milliseconds,this}withKeepAliveInterval(milliseconds){return Arg.isRequired(milliseconds,"milliseconds"),this._keepAliveIntervalInMilliseconds=milliseconds,this}withStatefulReconnect(options){return void 0===this.httpConnectionOptions&&(this.httpConnectionOptions={}),this.httpConnectionOptions._useStatefulReconnect=!0,this._statefulReconnectBufferSize=null==options?void 0:options.bufferSize,this}build(){const httpConnectionOptions=this.httpConnectionOptions||{};if(void 0===httpConnectionOptions.logger&&(httpConnectionOptions.logger=this.logger),!this.url)throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");const connection=new HttpConnection(this.url,httpConnectionOptions);return HubConnection.create(connection,this.logger||NullLogger.instance,this.protocol||new JsonHubProtocol,this.reconnectPolicy,this._serverTimeoutInMilliseconds,this._keepAliveIntervalInMilliseconds,this._statefulReconnectBufferSize)}}}}]);